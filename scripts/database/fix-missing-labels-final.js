/**
 * Generate actual PDF label files for approved shipments
 */
import { promises as fs } from 'fs';
import path from 'path';
import PDFDocument from 'pdfkit';
import QRCode from 'qrcode';
import JsBarcode from 'jsbarcode';
import { createCanvas } from 'canvas';
import postgres from 'postgres';

const sql = postgres(process.env.DATABASE_URL);

// Barcode generation function
function generateBarcodeAsSvg(data) {
  const canvas = createCanvas(200, 50);
  JsBarcode(canvas, data, {
    format: "CODE128",
    width: 2,
    height: 50,
    displayValue: false
  });
  return canvas.toDataURL();
}

// Generate tracking number
function generateTrackingNumber(shipmentId) {
  const prefix = "MS";
  const paddedId = shipmentId.toString().padStart(8, '0');
  return `${prefix}${paddedId}`;
}

// Generate tracking URL
function generateTrackingUrl(shipmentId) {
  return `https://moogship.com/track/${generateTrackingNumber(shipmentId)}`;
}

// Generate QR code
async function generateQRCode(text) {
  return await QRCode.toDataURL(text, { width: 100, margin: 1 });
}

// Generate shipping label
async function generateShippingLabel(shipment) {
  try {
    // Create label directory if it doesn't exist
    const labelDir = path.join(process.cwd(), "uploads", "labels");
    await fs.mkdir(labelDir, { recursive: true });

    // Generate a unique label filename
    const timestamp = Date.now();
    const labelPath = path.join(labelDir, `label-${shipment.id}-${timestamp}.pdf`);

    // Create barcode and QR code
    const trackingNumber = generateTrackingNumber(shipment.id);
    const barcodeData = generateBarcodeAsSvg(trackingNumber);
    const qrCodeData = await generateQRCode(generateTrackingUrl(shipment.id));

    // Create the PDF document
    const doc = new PDFDocument({
      size: [288, 432], // 4x6 inches in points
      margin: 10,
      bufferPages: true,
      autoFirstPage: true,
      layout: "portrait",
      compress: true,
    });

    // Pipe the PDF to a file
    const stream = doc.pipe(require('fs').createWriteStream(labelPath));

    // Header with company logo/name
    doc.fontSize(14).font('Helvetica-Bold').text('MoogShip', 10, 15);
    doc.fontSize(8).font('Helvetica').text('Global Shipping Solutions', 10, 32);

    // Tracking number and barcode
    doc.fontSize(12).font('Helvetica-Bold').text('Tracking Number:', 10, 55);
    doc.fontSize(10).font('Helvetica').text(trackingNumber, 10, 70);

    // Add barcode image (simplified)
    doc.rect(10, 85, 200, 30).stroke();
    doc.fontSize(8).text('*BARCODE*', 100, 95);

    // From section
    doc.fontSize(10).font('Helvetica-Bold').text('FROM:', 10, 125);
    doc.fontSize(8).font('Helvetica')
      .text(shipment.sender_name || 'Sender', 10, 140)
      .text(shipment.sender_address || 'Address', 10, 152)
      .text(`${shipment.sender_city || 'City'}, ${shipment.sender_postal_code || 'Postal'}`, 10, 164);

    // To section
    doc.fontSize(10).font('Helvetica-Bold').text('TO:', 10, 185);
    doc.fontSize(8).font('Helvetica')
      .text(shipment.receiver_name || 'Receiver', 10, 200)
      .text(shipment.receiver_address || 'Address', 10, 212)
      .text(`${shipment.receiver_city || 'City'}, ${shipment.receiver_postal_code || 'Postal'}`, 10, 224)
      .text(shipment.receiver_country || 'Country', 10, 236);

    // Package details
    doc.fontSize(10).font('Helvetica-Bold').text('PACKAGE DETAILS:', 10, 255);
    doc.fontSize(8).font('Helvetica')
      .text(`Weight: ${shipment.package_weight || 'N/A'} kg`, 10, 270)
      .text(`Dimensions: ${shipment.package_length || 'N/A'} x ${shipment.package_width || 'N/A'} x ${shipment.package_height || 'N/A'} cm`, 10, 282)
      .text(`Value: $${(shipment.package_value || 0) / 100}`, 10, 294);

    // Service type
    doc.fontSize(8).font('Helvetica')
      .text(`Service: ${shipment.service_type || 'Standard'}`, 10, 310);

    // QR code area (simplified)
    doc.rect(200, 300, 70, 70).stroke();
    doc.fontSize(6).text('QR', 230, 330);

    // Footer
    doc.fontSize(6).font('Helvetica')
      .text('Generated by MoogShip - www.moogship.com', 10, 410);

    // End the document
    doc.end();

    // Wait for the stream to finish
    await new Promise((resolve, reject) => {
      stream.on('finish', resolve);
      stream.on('error', reject);
    });

    console.log(`Label generated: ${labelPath}`);
    return labelPath;

  } catch (error) {
    console.error('Error generating label:', error);
    throw error;
  }
}

async function fixMissingLabels() {
  try {
    console.log('Generating actual PDF files for approved shipments...');
    
    // Get shipments that need label files
    const result = await sql`
      SELECT * FROM shipments 
      WHERE id IN (160, 161, 162, 163, 164) 
      AND status = 'approved'
      AND label_url IS NOT NULL
    `;
    
    console.log(`Found ${result.length} shipments needing label files`);
    
    for (const shipment of result) {
      try {
        console.log(`Generating PDF for shipment ${shipment.id}...`);
        
        // Generate the actual PDF file
        const labelResult = await generateShippingLabel(shipment);
        
        // Convert to relative URL
        const labelUrl = labelResult.labelPath.replace(process.cwd(), '');
        const finalUrl = labelUrl.startsWith('/') ? labelUrl : `/${labelUrl}`;
        
        // Update the database with the correct path
        await sql`
          UPDATE shipments 
          SET label_url = ${finalUrl}
          WHERE id = ${shipment.id}
        `;
        
        console.log(`✓ PDF generated and updated for shipment ${shipment.id}: ${finalUrl}`);
        
      } catch (error) {
        console.error(`✗ Error processing shipment ${shipment.id}:`, error.message);
      }
    }
    
    console.log('Label file generation completed!');
    
  } catch (error) {
    console.error('Error in label file generation process:', error);
  } finally {
    await sql.end();
  }
}

fixMissingLabels();