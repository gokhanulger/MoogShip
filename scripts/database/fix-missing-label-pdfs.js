/**
 * Fix missing label PDFs by regenerating them for shipments that have label URLs
 * but no actual PDF files or stored PDF data
 */

import pkg from 'pg';
const { Pool } = pkg;
import fs from 'fs';
import path from 'path';
import PDFDocument from 'pdfkit';

// Database connection
const pool = new Pool({
  connectionString: process.env.DATABASE_URL
});

/**
 * Generate a proper PDF label for a shipment
 */
function generatePdfLabel(shipment) {
  return new Promise((resolve, reject) => {
    try {
      // Create PDF document
      const doc = new PDFDocument({
        size: [288, 432], // 4x6 inches thermal printer size
        margin: 10
      });

      const chunks = [];
      doc.on('data', chunk => chunks.push(chunk));
      doc.on('end', () => {
        const pdfBuffer = Buffer.concat(chunks);
        resolve(pdfBuffer.toString('base64'));
      });

      // Add header
      doc.fontSize(16).font('Helvetica-Bold').text('MoogShip Label', { align: 'center' });
      doc.moveDown(0.5);

      // Shipment info
      doc.fontSize(12).font('Helvetica');
      doc.text(`Shipment #${shipment.id}`, { align: 'center' });
      doc.text(`Tracking: ${shipment.tracking_number || 'N/A'}`, { align: 'center' });
      doc.moveDown();

      // Sender section
      doc.fontSize(10).font('Helvetica-Bold').text('FROM:', { underline: true });
      doc.font('Helvetica').fontSize(9);
      doc.text(`${shipment.sender_name || 'N/A'}`);
      doc.text(`${shipment.sender_address || 'N/A'}`);
      doc.text(`${shipment.sender_city || 'N/A'} ${shipment.sender_postal_code || 'N/A'}`);
      doc.moveDown();

      // Receiver section
      doc.fontSize(10).font('Helvetica-Bold').text('TO:', { underline: true });
      doc.font('Helvetica').fontSize(9);
      doc.text(`${shipment.receiver_name || 'N/A'}`);
      doc.text(`${shipment.receiver_address || 'N/A'}`);
      doc.text(`${shipment.receiver_city || 'N/A'} ${shipment.receiver_postal_code || 'N/A'}`);
      doc.text(`${shipment.receiver_country || 'N/A'}`);
      doc.moveDown();

      // Package details
      doc.fontSize(10).font('Helvetica-Bold').text('PACKAGE DETAILS:', { underline: true });
      doc.font('Helvetica').fontSize(9);
      doc.text(`Contents: ${shipment.contents || 'General Goods'}`);
      if (shipment.weight) {
        doc.text(`Weight: ${shipment.weight} kg`);
      }
      if (shipment.dimensions) {
        doc.text(`Dimensions: ${shipment.dimensions}`);
      }
      if (shipment.customs_value) {
        doc.text(`Value: $${(shipment.customs_value / 100).toFixed(2)}`);
      }
      doc.moveDown();

      // Service info
      doc.fontSize(8).text(`Service: ${shipment.service_level || 'Standard'}`);
      doc.text(`Created: ${new Date(shipment.created_at).toLocaleDateString()}`);
      
      // Footer
      doc.fontSize(8).text('Generated by MoogShip Global Shipping', { align: 'center' });

      doc.end();
    } catch (error) {
      reject(error);
    }
  });
}

/**
 * Check if a file exists at the given path
 */
function fileExists(filePath) {
  try {
    return fs.existsSync(path.join(process.cwd(), filePath));
  } catch (error) {
    return false;
  }
}

/**
 * Save PDF to filesystem
 */
function savePdfToFile(pdfBase64, filePath) {
  try {
    const fullPath = path.join(process.cwd(), filePath);
    const dir = path.dirname(fullPath);
    
    // Ensure directory exists
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }
    
    const pdfBuffer = Buffer.from(pdfBase64, 'base64');
    fs.writeFileSync(fullPath, pdfBuffer);
    return true;
  } catch (error) {
    console.error(`Error saving PDF to ${filePath}:`, error);
    return false;
  }
}

/**
 * Main function to fix missing labels
 */
async function fixMissingLabels() {
  try {
    console.log('ğŸ” Finding shipments with missing label PDFs...');
    
    // Get all shipments that have label URLs but missing files or PDF data
    const result = await pool.query(`
      SELECT id, sender_name, receiver_name, sender_address, receiver_address,
             sender_city, sender_postal_code, 
             receiver_city, receiver_postal_code, receiver_country,
             contents, weight, dimensions, customs_value, service_level,
             tracking_number, label_url, label_pdf, created_at
      FROM shipments 
      WHERE label_url IS NOT NULL 
      AND (label_pdf IS NULL OR label_pdf = '')
      ORDER BY id
    `);

    const shipments = result.rows;
    console.log(`ğŸ“‹ Found ${shipments.length} shipments with missing PDF data`);

    if (shipments.length === 0) {
      console.log('âœ… No shipments need PDF regeneration');
      return;
    }

    let fixed = 0;
    let errors = 0;

    for (const shipment of shipments) {
      try {
        console.log(`\nğŸ”§ Processing shipment ${shipment.id}...`);
        
        // Check if file exists on filesystem
        const fileExists = shipment.label_url ? fileExists(shipment.label_url) : false;
        
        if (!fileExists) {
          console.log(`   ğŸ“„ Generating new PDF for shipment ${shipment.id}`);
          
          // Generate new PDF
          const pdfBase64 = await generatePdfLabel(shipment);
          
          if (pdfBase64) {
            // Save to database
            await pool.query(`
              UPDATE shipments 
              SET label_pdf = $1, updated_at = NOW()
              WHERE id = $2
            `, [pdfBase64, shipment.id]);
            
            // Also save to filesystem if we have a label_url
            if (shipment.label_url) {
              const saved = savePdfToFile(pdfBase64, shipment.label_url);
              if (saved) {
                console.log(`   âœ… Saved PDF to database and filesystem for shipment ${shipment.id}`);
              } else {
                console.log(`   âš ï¸  Saved PDF to database but failed to save to filesystem for shipment ${shipment.id}`);
              }
            } else {
              console.log(`   âœ… Saved PDF to database for shipment ${shipment.id}`);
            }
            
            fixed++;
          } else {
            console.log(`   âŒ Failed to generate PDF for shipment ${shipment.id}`);
            errors++;
          }
        } else {
          console.log(`   âœ… File exists for shipment ${shipment.id}, skipping`);
        }
        
      } catch (error) {
        console.error(`   âŒ Error processing shipment ${shipment.id}:`, error);
        errors++;
      }
    }

    console.log(`\nğŸ“Š Summary:`);
    console.log(`   âœ… Fixed: ${fixed} shipments`);
    console.log(`   âŒ Errors: ${errors} shipments`);
    console.log(`   ğŸ“„ Total processed: ${shipments.length} shipments`);

  } catch (error) {
    console.error('âŒ Error in fixMissingLabels:', error);
  }
}

/**
 * Clean up orphaned label URLs (where files don't exist)
 */
async function cleanupOrphanedUrls() {
  try {
    console.log('\nğŸ§¹ Cleaning up orphaned label URLs...');
    
    const result = await pool.query(`
      SELECT id, label_url 
      FROM shipments 
      WHERE label_url IS NOT NULL 
      AND label_pdf IS NULL
    `);

    let cleaned = 0;
    
    for (const shipment of result.rows) {
      if (!fileExists(shipment.label_url)) {
        // File doesn't exist, clear the URL so it can be regenerated
        await pool.query(`
          UPDATE shipments 
          SET label_url = NULL, updated_at = NOW()
          WHERE id = $1
        `, [shipment.id]);
        
        console.log(`   ğŸ—‘ï¸  Cleared orphaned URL for shipment ${shipment.id}`);
        cleaned++;
      }
    }
    
    console.log(`   âœ… Cleaned ${cleaned} orphaned URLs`);
    
  } catch (error) {
    console.error('âŒ Error cleaning orphaned URLs:', error);
  }
}

// Run the fix
async function main() {
  console.log('ğŸš€ Starting label PDF fix process...');
  
  await fixMissingLabels();
  await cleanupOrphanedUrls();
  
  console.log('\nğŸ‰ Label PDF fix process completed!');
  process.exit(0);
}

// Run if this is the main module
main().catch(error => {
  console.error('âŒ Fatal error:', error);
  process.exit(1);
});